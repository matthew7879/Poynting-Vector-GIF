import glob
from PIL import Image
import io 
import math
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import cmath
import numpy as np
import scipy.special as sp
alpha=7*10**(-6)
wavelength = 1310*10**(-9)
m=1
n1 = 1.47093878 
n2 = 1.46426121
c=3*10**8
w = 2*math.pi*c/wavelength
mu = 4*math.pi*10**(-7)
Beta_value =  7040810.660769327
Phi0 = 2*math.pi
v=m*math.pi/Phi0
Beta_t=math.sqrt( (w**2/c**2) * n1**2 - Beta_value**2 )
q_t = math.sqrt(Beta_value**2-w**2/c**2*n2**2)
phase = math.pi/3

def condition(X,Y):
    return X**2 + Y**2 < 4.9*10**(-11)

def foutsidex(x,y,phase):
    Hz =(-10.41467848*sp.kv(v,q_t*x)+0.03008456*sp.iv(v,q_t*x))*np.sin(v*y)
    Hrho = 1/(q_t**2)*(-w*n2**2*v/(mu*x*c**2)*(sp.kv(v,q_t*x)*-12.43133101+sp.iv(v,q_t*x)*0.03591001)*np.cos(v*y)+Beta_value*q_t*(sp.kvp(v,q_t*x)*-10.41467848+sp.ivp(v,q_t*x)*0.03008456)*np.sin(v*y))
    Hphi = 1/(q_t**2)*(w*n2**2*q_t/(mu*c**2)*(sp.kvp(v,q_t*x)*-12.43133101+sp.ivp(v,q_t*x)*0.03591001)*np.sin(v*y)+Beta_value*v/x*(sp.kv(v,q_t*x)*-10.41467848+sp.iv(v,q_t*x)* 0.03008456)*np.cos(v*y))
    
    Ez = (-12.43133101*sp.kv(v,q_t*x)+0.03591001*sp.iv(v,q_t*x))*np.sin(v*y)
    Erho = 1/((q_t)**2)*(Beta_value*q_t*(-12.43133101*sp.kvp(v,q_t*x)+0.03591001*sp.ivp(v,q_t*x))*np.sin(v*y)+w*mu*v/x*(-10.41467848*sp.kv(v,q_t*x)+0.03008456*sp.iv(v,q_t*x))*np.cos(v*y))
    Ephi = 1/((q_t)**2)*(Beta_value*v/x*(-12.43133101*sp.kv(v,Beta_t*x)+0.03591001*sp.iv(v,q_t*x))*np.cos(v*y)-w*mu*q_t*(-10.41467848*sp.kvp(v,q_t*x)+0.03008456*sp.ivp(v,q_t*x))*np.sin(v*y))
    return n2**2*(-np.cos(phase)*np.sin(phase)*((Ephi*Hz-Ez*Hphi)*np.cos(y)-(Ez*Hrho-Erho*Hz)*np.sin(y)))

def foutsidey(x,y,phase):
    Hz =(-10.41467848*sp.kv(v,q_t*x)+0.03008456*sp.iv(v,q_t*x))*np.sin(v*y)
    Hrho = 1/(q_t**2)*(-w*n2**2*v/(mu*x*c**2)*(sp.kv(v,q_t*x)*-12.43133101+sp.iv(v,q_t*x)*0.03591001)*np.cos(v*y)+Beta_value*q_t*(sp.kvp(v,q_t*x)*-10.41467848+sp.ivp(v,q_t*x)*0.03008456)*np.sin(v*y))
    Hphi = 1/(q_t**2)*(w*n2**2*q_t/(mu*c**2)*(sp.kvp(v,q_t*x)*-12.43133101+sp.ivp(v,q_t*x)*0.03591001)*np.sin(v*y)+Beta_value*v/x*(sp.kv(v,q_t*x)*-10.41467848+sp.iv(v,q_t*x)* 0.03008456)*np.cos(v*y))
    
    Ez = (-12.43133101*sp.kv(v,q_t*x)+0.03591001*sp.iv(v,q_t*x))*np.sin(v*y)
    Erho = 1/((q_t)**2)*(Beta_value*q_t*(-12.43133101*sp.kvp(v,q_t*x)+0.03591001*sp.ivp(v,q_t*x))*np.sin(v*y)+w*mu*v/x*(-10.41467848*sp.kv(v,q_t*x)+0.03008456*sp.iv(v,q_t*x))*np.cos(v*y))
    Ephi = 1/((q_t)**2)*(Beta_value*v/x*(-12.43133101*sp.kv(v,Beta_t*x)+0.03591001*sp.iv(v,q_t*x))*np.cos(v*y)-w*mu*q_t*(-10.41467848*sp.kvp(v,q_t*x)+0.03008456*sp.ivp(v,q_t*x))*np.sin(v*y))
    return n2**2*(-np.cos(phase)*np.sin(phase)*((Ephi*Hz-Ez*Hphi)*np.sin(y)+(Ez*Hrho-Erho*Hz)*np.cos(y)))

def finsidex(x,y,phase):
    Hz = sp.jv(v,Beta_t*x)*np.sin(v*y)
    Hrho = -1/(Beta_t**2)*(-w*(n1**2)*v/(mu*x*c**2)*sp.jv(v,Beta_t*x)*np.cos(v*y)+Beta_value*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y))
    Hphi = -1/(Beta_t**2)*(w*(n1**2)*Beta_t/(mu*c**2)*sp.jvp(v,Beta_t*x)*np.sin(v*y)+Beta_value*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y))
    
    Ez = sp.jv(v,Beta_t*x)*np.sin(v*y)
    Erho = -1/(Beta_t**2)*(Beta_value*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y)+w*mu*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y))
    Ephi = -1/(Beta_t**2)*(Beta_value*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y)-w*mu*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y))
    return  n1**2*(-np.cos(phase)*np.sin(phase)*((Ephi*Hz-Ez*Hphi)*np.cos(y)-(Ez*Hrho-Erho*Hz)*np.sin(y)))

def finsidey(x,y,phase):
    Hz = sp.jv(v,Beta_t*x)*np.sin(v*y)
    Hrho = -1/(Beta_t**2)*(-w*(n1**2)*v/(mu*x*c**2)*sp.jv(v,Beta_t*x)*np.cos(v*y)+Beta_value*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y))
    Hphi = -1/(Beta_t**2)*(w*(n1**2)*Beta_t/(mu*c**2)*sp.jvp(v,Beta_t*x)*np.sin(v*y)+Beta_value*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y))
    
    Ez = sp.jv(v,Beta_t*x)*np.sin(v*y)
    Erho = -1/(Beta_t**2)*(Beta_value*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y)+w*mu*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y))
    Ephi = -1/(Beta_t**2)*(Beta_value*v/x*sp.jv(v,Beta_t*x)*np.cos(v*y)-w*mu*Beta_t*sp.jvp(v,Beta_t*x)*np.sin(v*y))
    return n1**2*(-np.cos(phase)*np.sin(phase)*((Ephi*Hz-Ez*Hphi)*np.sin(y)+(Ez*Hrho-Erho*Hz)*np.cos(y)))

def fixalpha(x):
    # assume rgb premultiplied by alpha
    rgb, a = x[..., :3], x[...,3]
    a=np.stack([a,a,a],axis=2)
    y=np.ones_like(x)
    y[..., :3] = (255-a)+rgb
    return y

r = np.linspace(2*10**(-8),0.695*10**(-5),100)
phi = np.linspace(0,2*math.pi,100)
R, P =np.meshgrid(r,phi)
X, Y =R*np.cos(P),R*np.sin(P)
inside = condition(X,Y)
outside =~ inside


phases = np.linspace(0,2*math.pi,100)

allframes=[]

for z in range(0,100):
    phase = phases[z]
    Zx = foutsidex(R,P,phase)*outside + finsidex(R,P,phase)*inside
    Zy = foutsidey(R,P,phase)*outside + finsidey(R,P,phase)*inside
    fig = plt.figure()
    axs = fig.add_subplot(111)
    plt.quiver(X,Y,Zx,Zy)
    axs.axis('off')
    with io.BytesIO() as buff:
        fig.savefig(buff, format='raw')
        fig.clf()
        plt.close()
        data = np.frombuffer(buff.getvalue(), dtype=np.uint8)
        w, h = fig.bbox.bounds[2:]
        data = data.reshape((int(h), int(w), -1))
        image_data = data.astype('uint8')
        allframes+=[Image.fromarray(fixalpha(image_data))]
    print(z,len(allframes),end=" |")

print("Done Graphing, now saving")


# filepaths
fp_out = "Poynting Vector real solution m = 1.gif"
# https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html#gif
img, *imgs = allframes
img.save(fp=fp_out, format='GIF', append_images=imgs,
         save_all=True, duration=20, loop=0)
